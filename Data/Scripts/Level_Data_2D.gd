#@tool
class_name Level_Data_2D extends Level_Data
#contains ref to tilemaps, how to handle null ref, and level related data

###NOTE: this is the old system. it will be converted to the new system(level_data)
###TODO: static chunks need to be work on more. system using old system data for them which
#a bit too vague. also the foliage is being generated by one_bit_tilemaps. may need to have
#a solution here to handle it or keep it as is and just save the noisemap. later allow
#world gen to be similar/same with foilage or features
#TODO: also generator is simple. no water and using the old generator. 
#need at least a system to check nearby tilemaps types and lerp to a neutral level
#this is mostly only for major terrain like water or mountains or forests
#the idea is to lerp, but also use a random noise to add varation to the lerp final point
#so it not a perfect circle or square, but more jagged

#this should be what generate if there is no static chunk
#note, not sure if packed scenr need to be loaded 
#@export var default_chunk : PackedScene #= preload("res://Data/Scenes/TilemapTemplate.tscn")
@export_file("*.tscn") var default_chunk : String = "res://Data/Scenes/Maps/TilemapTemplate.tscn"
#@export var null_chunk : PackedScene
@export_file("*.tscn") var null_chunk : String = "res://Data/Scenes/Maps/NullZone.tscn"
@export var return_null_on_default: bool = false 


#may use this instead of return_null_on_default
#will generate default or random tiles up to bounds unless ignored. 
@export var level_max_bounds: Vector2
@export var level_min_bounds: Vector2
@export var use_level_bounds: bool = false
@export var use_game_seed: bool = true

#Noise should be related to level which basicly world data
#also should decide how to seed them. could base it on world seed +- an offset
#or have it fixed and have the seed editable. if world noise map, could use a save object, just need to
#seed it game start.
@export var tempture_map : Noise
@export var humidity_map : Noise
#detail is ment to be for if a feature spawn or it empty space/unchanged. 
@export var detail_map : Noise
#variation is for picking the variation of a tile.
@export var variation_map : Noise
@export var height_map : Noise = FastNoiseLite.new()
#note: a way to handle random chunks are still needed. currently usong array[0] inless 10% chance
#is rolled...then a random array between 0-max is picked

#test: this is to generate water and mountains. current max value is 100
#height is the noise that state if it land or water
#water is an offset that would generate water above sealevel as long as hight not as high
#hill are bumps to add more detail. making small hills or creating islands
#100 is max height and 0 is min height
#NOTE: water at 25 is no water. \
#so really it a three level noice map




#should be ref by id and loaded in via regions else if small then just need an object to get the data from
#@export var old_static_chunks : Dictionary = { 
	#Vector2(0,0):"uid://blyxjt47otoln", 
	#Vector2(4,8):"uid://clicnkneu0ddm",
	#Vector2(7,-2):"uid://bngicde5fixcp",
	#Vector2(-4,5):"uid://cyg3wosoq0787",
	#Vector2(-9,-6):"uid://t7rhh625brgr",
	#Vector2(-3,0):"uid://duqgklvehxux0",
	#Vector2(0,11):"uid://bbaafkh4f04vx",
	#Vector2(0,-21):"uid://t7rhh625brgr",
	#Vector2(42,0):"uid://clicnkneu0ddm"
	#}
	
@export var chunks : Array[Chunk_Data] :
	set(value):
		chunks = value
		sort_chunks()
	get:
		return chunks

#TODO add a region size/bound option to allow generation upto a certain size

var static_chunks = {}
var random_chunks = []


@export var tile_set : TileSet = preload("res://Data/Assets/low_Bit_Tileset.tres")

var tile_size : float = 16 #this is more dependent on the tile map, but the value should be fixed
var chunk_size : float = Region_Data.chunk_size
var region_size : float = Region_Data.chunk_size*Region_Data.region_size
var chunk_distance : float = tile_size*(region_size)

#currently loaded maps
var loaded_tilemaps := {}
#maps that are flaged out of range
var loose_tilemaps := {}
var max_loose_maps : int = 8
#static maps that can not be recycled
#currently not in use, but may be the opposite of processing. also tilemaps
#that are static will have additonal data. either a scene or an object with data and genration logic
var static_tilemaps := {}
#maps that are loaded, but not ready
var processing_tilemaps := {}
var processing : bool = false
#a array of catch positions. any tilemap not equal any will be move to loosed
var active_regions : Array[Vector2i]

var deferring_handle_tilemaps := false

var near_by_coords :Array[Vector2i] =[
		Vector2(-1,-1),Vector2(-1,0), Vector2(-1, 1),
		Vector2(0,0),Vector2(0,-1), Vector2(1, -1),
		Vector2(1,1),Vector2(0,1), Vector2(1,0)
	]
	
@export var grass_tiles : Array[Vector2i] = [Vector2i(5,0),Vector2i(6,0),
	Vector2i(7,0),Vector2i(0,2),Vector2i(0,0)]
@export var tree_tiles : Array[Vector2i] = [Vector2i(0,1),Vector2i(1,1),
	Vector2i(2,1),Vector2i(3,1),Vector2i(4,1),Vector2i(5,1),Vector2i(3,2),
	Vector2i(4,2),Vector2i(6,2),Vector2i(0,0)]
@export var rock_tiles : Array[Vector2i] = [Vector2i(5,2),Vector2i(1,0),
	Vector2i(2,0),Vector2i(3,0),Vector2i(4,0),Vector2i(0,0)]

#TODO: So far added a way to handle and load tilemap to replace the old system
#just need to move the generation logic over here

###oNE BIT TILEMAP GENERATION CODE PEICES

func pick_foliage_tile(pos):
	var noise_value = round((height_map.get_noise_2d(pos.x,pos.y)+1)*5)
	var water_value = round(height_map.get_noise_2d(pos.x,pos.y))
	var variation_roll = randf()
	var random_roll = randi() % 100
	if detail_map != null and variation_map != null:
		random_roll = (detail_map.get_noise_2d(pos.x*5,pos.y*5)+1)*50
		variation_roll = (variation_map.get_noise_2d(pos.x*5,pos.y*5)+1)/2
	
	if water_value < 0:
		return Vector2i(8,5)
	elif grass_tiles.size() > 0 && random_roll >= 50: #60:
		return grass_tiles[round((grass_tiles.size()-1)*variation_roll)]
	elif rock_tiles.size() > 0 && random_roll < 10:
		return rock_tiles[round((rock_tiles.size()-1)*variation_roll)]
	elif tree_tiles.size() > 0 && random_roll < 45:
		return tree_tiles[round((tree_tiles.size()-1)*variation_roll)]
	else:
		return Vector2i(0, 0)

##ONE BIT TILEMAP CODE END

func clear_tilemaps(tilemap_dictionary:Dictionary):
	for coords in tilemap_dictionary.keys():
		var tilemap = tilemap_dictionary[coords]
		level_removed.emit(tilemap)
		tilemap .queue_free()
		if static_tilemaps.has(coords):
			static_tilemaps.erase(coords)
		tilemap_dictionary.erase(coords)
	

func get_static_map(location:Vector2)->Node:
	for chunk in chunks:
		if chunk.is_static_chunk:
			if chunk.static_location == location:
				return load(chunk.chunk_scene_path).instantiate()
	return null

func tile_picker(tilemap:TileMap,coords:Vector2i):
	var tile = pick_foliage_tile(coords)
	#tilemap.call_deferred("set_cell",0,coords,0,tile)
	tilemap.set_cell(0,coords,0,tile)

func process_tilemaps():
	if !processing: 
		processing = true
	else:
		return
	while !processing_tilemaps.is_empty():
		for coords in processing_tilemaps.keys():
			var tilemap : TileMap = processing_tilemaps[coords]
			generate_tilemap(tilemap)
			#print("processing " + str(tilemap) + " at " + str(tilemap.position))
			
			loaded_tilemaps[coords] = tilemap
			processing_tilemaps.erase(coords)
			
		processing = !processing_tilemaps.is_empty()

func generate_tilemap(tilemap):
	for region_x in range(Region_Data.region_size):
		for region_y in range(Region_Data.region_size):
			for chunk_x in range(Region_Data.chunk_size):
				for chunk_y in range(Region_Data.chunk_size):
					tile_picker(tilemap,Vector2i(
						chunk_x + region_x * Region_Data.chunk_size,
						chunk_y + region_y * Region_Data.chunk_size
					))
			await Game.get_tree().create_timer(0.05).timeout

func is_tilemap_ready(coords:Vector2i) -> bool:
	if processing_tilemaps.has(coords):
		return false
	else:
		#if return false, tilemap dose not exist
		return dose_tilemap_exist(coords)

func dose_tilemap_exist(coords:Vector2i)-> bool:
	return (loaded_tilemaps.has(coords) or loose_tilemaps.has(coords)
		or processing_tilemaps.has(coords)
	)
	

func handle_tilemaps():
	#the timer is a placeholder. defer may be enough, so the update rate is all that may need to be handle
	#await Game.get_tree().create_timer(1.0).timeout
	for coords in active_regions:
		if loose_tilemaps.has(coords):
			#print_debug("flagging importaint" + str(coords) )
			loaded_tilemaps[coords] = loose_tilemaps[coords]
			loose_tilemaps.erase(coords)
		elif !dose_tilemap_exist(coords):
			#print_debug("flagging new" + str(coords) )
			var static_map = get_static_map(level_coords_to_world(coords))
			if static_map != null:
				loaded_tilemaps[coords] = static_map
				static_tilemaps[coords] = static_map
				level_created.emit(static_map)
				static_map.transform[2] = level_coords_to_world(coords)
			else:
				var new_tilemap = create_tilemap()
				init_tilemap(new_tilemap,level_coords_to_world(coords))
				processing_tilemaps[coords] = new_tilemap
				process_tilemaps()
	for loaded_coords in loaded_tilemaps.keys():
		var loaded_map = loaded_tilemaps[loaded_coords]
		if !active_regions.has(loaded_coords):
			#print_debug("flagging old" + str(loaded_coords))
			loose_tilemaps[loaded_coords] = loaded_tilemaps[loaded_coords]
			loaded_tilemaps.erase(loaded_coords)
	
	for loose_coords in loose_tilemaps.keys():
		var loose_map = loose_tilemaps[loose_coords]
		#remove
		if loose_tilemaps.size()>max_loose_maps:
			#print_debug("removing" + str(loose_coords) )
			level_removed.emit(loose_map)
			if loose_map != null:
				loose_map.queue_free()
			if static_tilemaps.has(loose_coords):
				static_tilemaps.erase(loose_coords)
			loose_tilemaps.erase(loose_coords)
			if loose_tilemaps.size()<=max_loose_maps:
				break
	active_regions.clear()
	deferring_handle_tilemaps = false

func caculate_active_regions(position:Vector2):
	var loader_coords = world_to_level_coords(position)
	for coord in near_by_coords:
		var grid_position = loader_coords + coord
		if !active_regions.has(grid_position):
			active_regions.append(grid_position)
		if !deferring_handle_tilemaps:
			call_deferred("handle_tilemaps")
			deferring_handle_tilemaps = true


func create_tilemap():
	var tilemap := TileMap.new()
	level_created.emit(tilemap)
	return tilemap

#NOTE: need to load and init tilemap. this just set things up
func init_tilemap(tilemap:TileMap,coords:Vector2):
	#loaded_tilemaps[location] = tilemap
	tilemap.y_sort_enabled = true
	tilemap.texture_filter =CanvasItem.TEXTURE_FILTER_NEAREST
	tilemap.set_layer_y_sort_enabled(0,true)
	tilemap.transform[2] = coords
	if tilemap.tile_set == null: #NOTE: may want to force the tile_set? random maps should not need diffrent type
		tilemap.tile_set = tile_set

#var grid_position = Vector2(x,y) + offset + loaded_point
func world_to_level_coords(position: Vector2) -> Vector2i :
	return (position/chunk_distance).floor()
	#return Vector2i(position.x, position.y)
func level_coords_to_world(coords: Vector2i) -> Vector2 :
	return coords * chunk_distance
	#return Vector2i(coords.x, coords.y)

func get_level_scene(position:Vector2):
	return get_chunk(position)
	#return null
	
func process_scene_instance(scene:Node,position:Vector2):
	pass
	
func load_level():
	pass
	#generate_chunks()
	
	#below is a way to store the scene 
	#ResourceLoader.load_threaded_request(default_chunk)
	#the can use this to get the scene.
	#var should be global or similar. may need to unload as well
	#var default_chunk_scene = ResourceLoader.load_threaded_get(default_chunk)

func unload_level():
	print("MEOOOOOOOW")
	clear_tilemaps(loaded_tilemaps)
	clear_tilemaps(processing_tilemaps)
	clear_tilemaps(loose_tilemaps)
	#clear_chunks(loaded_chunks.keys())
	pass

func process_players(pawn:Node):
	if pawn as Node2D:
		var grid_location = world_to_level_coords(pawn.global_position) as Vector2
		loaded_point = grid_location
		caculate_active_regions(pawn.global_position)



###WORLD Handler old logic###

#var tile_size : float = 16 #this is more dependent on the tile map, but the value should be fixed
#var chunk_size : float = Region_Data.chunk_size*Region_Data.region_size
#todo: load/save this value prbably in a world save. most seeds could be handle
#by the noise settings, but sometime a seed may need to be shared
var world_seed : int = 0

#var chunk_distance = tile_size*(chunk_size)
#var chunk_distance = tile_size*Region_Data.chunk_size*Region_Data.region_size


var offset = Vector2(-2,-2)
var loaded_point = Vector2(0,0):
	set(value):
		loaded_point = value
#		generate_chunks()
var loaded_chunks = {}

func load_chunks(pos):
	var current_origin = loaded_point * chunk_distance
	if (pos.x >= current_origin.x + chunk_distance ||
		pos.x <= current_origin.x - chunk_distance ||
		pos.y >= current_origin.y + chunk_distance ||
		pos.y <= current_origin.y - chunk_distance ) :
			loaded_point = world_to_level_coords(pos) as Vector2
			#loaded_point = (pos/chunk_distance).round()
			#generate_chunks()

func generate_chunks() :
	var local_offset = Vector2(-1,-1)
	#var chunk_distance = tile_size*(chunk_size+1)
	var old_chunk_coord = loaded_chunks.keys()
	var x = 0
	var y = 0
	for point in [
		Vector2(-1,-1),Vector2(-1,0), Vector2(-1, 1),
		Vector2(0,0),Vector2(0,-1), Vector2(1, -1),
		Vector2(1,1),Vector2(0,1), Vector2(1,0)
	]:
		var grid_position =  loaded_point + point
		if !loaded_chunks.has(grid_position):
			var map
			var chunk_ref = get_level_scene(grid_position)
				#var chunk_ref = level_data.get_chunk(grid_position)
			if chunk_ref != null:
					#print("loading: " + str(chunk_ref))
				call_deferred("load_chunk",chunk_ref,grid_position,!chunk_ref is String)
		else:
			old_chunk_coord.remove_at(old_chunk_coord.find(grid_position))
	clear_chunks(old_chunk_coord)
	return
	while x <= 3:
		while y <= 3:
			var grid_position = Vector2(x,y) + local_offset + loaded_point
			if !loaded_chunks.has(grid_position):
				var map
				var chunk_ref = get_level_scene(grid_position)
					#var chunk_ref = level_data.get_chunk(grid_position)
				if chunk_ref != null:
						#print("loading: " + str(chunk_ref))
					call_deferred("load_chunk",chunk_ref,grid_position,!chunk_ref is String)
					await Game.get_tree().create_timer(1.0).timeout

			else:
				old_chunk_coord.remove_at(old_chunk_coord.find(grid_position))
			y += 1
		y = 0
		x += 1
	clear_chunks(old_chunk_coord)
	
func clear_chunks(old_chunk_coords : Array ):
	for null_pos in old_chunk_coords:
		
		chunk_update(loaded_chunks[null_pos], null_pos, true) #map may be null

		level_removed.emit(loaded_chunks[null_pos])
		loaded_chunks[null_pos].queue_free()
		loaded_chunks.erase(null_pos)

func load_chunk(ref,location = Vector2(), is_loaded = true) :
	#var base_map = create_tilemap()
	#init_tilemap(base_map,location)
	var map
	if loaded_chunks.has(location):
		#print_debug("warning location exist, ignoring loading chunk")
		return
	if is_loaded :
		map = ref.instantiate()
	else:
		var loaded_ref = load(ref)
		map = loaded_ref.instantiate()
	map.chunk_size = chunk_size
	map.random_noise = height_map
	map.detail_map = detail_map
	map.variation_map = variation_map
	#map.height_value = get_height_value
	map.transform[2] = chunk_distance * location
	level_created.emit(map)
	loaded_chunks[location] = map
	#map.connect("on_chunk_ready", chuck_ready)
	if map.has_signal("on_chunk_ready"): #tool cause errors here so map may not be fully ready? 
		map.on_chunk_ready.connect(map_ready)

		
	#todo, decide on a better location. this call it when a new map is spawn(since currently each map a chunk)
	chunk_update(map, location, false)

func level_bounds_entered(data):
	if data.is_in_group("players"):
		pass
var loaders := []
var updating:=false


func get_current_chunk(location):
	var chunk_pos = world_to_level_coords(location) as Vector2
	#var chunk_pos = (location/chunk_distance).round()
	#print(chunk_pos)
	if loaded_chunks.has(chunk_pos):
		return loaded_chunks[chunk_pos]
	#elif preloaded_chunks.has(chunk_pos):
	#	return preloaded_chunks[chunk_pos]
	else:
		return null
		

func map_ready(pos,is_ready = true):
	pass
	
func chunk_update(map,pos,is_ready = true):
	#need to decide on pos or chunk pos. the signal use pos, but unload use chunk
	#the issues is where map size is located(currently here) so children do not know about it
	var map_size = chunk_size * tile_size
	#TODO: see if this function still can be useful. maybe to notify loader objects
	#if is_ready:
	#	get_tree().call_group("Player_Handlers", "chunk_update", (pos/map_size).round(), map_size, is_ready)
	#else:
	#	get_tree().call_group("Player_Handlers", "chunk_update", pos, map_size, is_ready)
		
		
#todo: need to change the logic in the world handler or map so that chunks are updated
#as a player move and there is non loaded around them. right now it logic hard to read
#and the new system break for north and west chunks
func is_chunk_loaded(location,  load = true):
	#return true
	#map size not needed since there a var that better above(chunk_distance).
	#var map_size = chunk_size * tile_size
	var grid_location = world_to_level_coords(location) as Vector2
	#var grid_location = (location/chunk_distance).floor()
	if load:
		call_deferred("load_chunks",location)
		#load_chunks(location)
		#loaded_point = grid_location
		#generate_chunks()
	if loaded_chunks.has(grid_location):
		return loaded_chunks[grid_location].visible
	else:
		return false
	
	
###world old logic END###





func _init():
	randomize_zero_seed(tempture_map)
	randomize_zero_seed(humidity_map)
	randomize_zero_seed(detail_map)
	randomize_zero_seed(variation_map)

func randomize_zero_seed(noise: Noise):
	if (noise != null):
		if noise.seed == 0:
			noise.seed = randi()

func seed_maps(new_seed : int):
	if use_game_seed :
		if (tempture_map != null):
			tempture_map.seed = new_seed
		if (humidity_map != null):
			humidity_map.seed = new_seed
		if (detail_map != null):
			detail_map.seed = new_seed
		if (variation_map != null):
			variation_map.seed = new_seed

#NOTE: should just have chunks and this will sort it into static and random dict
#the default can be empty or filled out, but a flag may be needed to overrided return hull on default
func sort_chunks():
	if static_chunks.is_empty() && chunks.size() > 0:
		for chunk_data in chunks:
			var chunk_scene = chunk_data.chunk_scene_path
			if ResourceLoader.exists(chunk_scene, "PackedScene"):
				if chunk_data.is_static_chunk:
					static_chunks[chunk_data.static_location] = chunk_scene
				else:
					random_chunks.append(chunk_scene)
			else:
				print_debug(str(chunk_scene) + " is not vaild scene")

func get_chunk(grid_location = Vector2()):
	if grid_location in static_chunks:
		#print_debug("new static chunk is being called")
		return static_chunks[grid_location]
	else:
		if use_level_bounds:
			#issue: grid_loaction not as bounding box. need to offset it to be positive
			if (grid_location.x <= level_max_bounds.x && grid_location.y <= level_max_bounds.y &&
				grid_location.x >= level_min_bounds.x && grid_location.y >= level_min_bounds.y):
				if randi() % 100 > 90 && random_chunks.size() > 0:
					#print_debug("rare chunk")
					return random_chunks[randi() % random_chunks.size()]
				else:
					return default_chunk 
			else:
				#print_debug("null chunk")
				return null_chunk
		if default_chunk != null || !return_null_on_default:
			if randi() % 100 > 90 && random_chunks.size() > 0:
				#print_debug("rare chunk")
				return random_chunks[randi() % random_chunks.size()]
			else:
				return default_chunk
	#print_debug("null chunk")
	return null_chunk
